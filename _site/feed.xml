<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-15T01:01:52-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hasan Unlu’s Blog</title><entry><title type="html">Motor Controller Software and Circuit for Dyson Vacuum Cleaner Motors</title><link href="http://localhost:4000/2023/06/14/Motor-Controller-Software-and-Circuit-for-Dyson-Vacuum-Cleaner-Motors.html" rel="alternate" type="text/html" title="Motor Controller Software and Circuit for Dyson Vacuum Cleaner Motors" /><published>2023-06-14T10:46:39-07:00</published><updated>2023-06-14T10:46:39-07:00</updated><id>http://localhost:4000/2023/06/14/Motor-Controller-Software-and-Circuit-for-Dyson-Vacuum-Cleaner-Motors</id><content type="html" xml:base="http://localhost:4000/2023/06/14/Motor-Controller-Software-and-Circuit-for-Dyson-Vacuum-Cleaner-Motors.html"><![CDATA[<p>Dyson V6 Setup</p>
<div class="video-holder">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/YlLNd6wKVhU" frameborder="0" allowfullscreen=""></iframe>
</div>
<p><br />
<br />
Dyson V10 Setup</p>
<div class="video-holder">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/e8ecWtvUDWA" frameborder="0" allowfullscreen=""></iframe>
</div>
<p><br />
Dyson handheld vacuum cleaners utilize high RPM brushless DC motors. Specifications indicate that some models can reach as high as 125000 RPM. I’ve disassembled DC56(V2), V6, and V10 models. Each has a brushless single-phase motor, with differing number of poles: two for the DC56, four for the V6, and eight for the V10. An earlier <a href="https://www.electronicsweekly.com/market-sectors/power/dyson-vacuums-104000rpm-brushless-dc-technology-2009-06/">article</a> about their DC56(V2) motor hinted that besides the mechanical design, the controlling software is the key. The electronics are relatively straightforward, including an H-bridge driver, microcontroller, and hall effect sensor. I’ve taken up the task and developed my own software to match Dyson’s factory performance. My software could potentially be used with all their brushless motors. The components I utilized include an Arduino Uno (8-bit ATmega328P microcontroller), H-bridge controller, and a hall effect sensor. Despite Dyson V10 employing a 32-bit ARM micro-controller, I managed to control it using an 8-bit Arduino, which is cheaper component.</p>

<p align="center" width="100%">
    <img width="30%" src="/assets/v6_setup.jpg" /> 
    &emsp;&emsp;
    <img width="37%" src="/assets/v10_setup.jpg" /> 
</p>
<div align="center">
V6 and V10 Setup</div>
<p><br />
<br />
<strong>1. Hall Effect Sensor</strong>
<br />
I reused the hall effect sensor from the original control board, but it can also be sourced from retailers such as Digikey, Adafruit, or Sparkfun. This sensor requires a pull-up resistor (~5k ohm) at the output pin.</p>

<p><img src="/assets/hall_effect_sensor_pinout.png" alt="Hall Effect Sensor Pinout" style="display:block; margin-left:auto; margin-right:auto" /></p>
<div align="center">
Hall Effect Sensor Pinout
</div>
<p><br />
<br />
<strong>2. H-Bridge Driver</strong>
<br />
Several H-Bridge options are available on the market, but considering these beasts can consume ~500 watts, it’s preferable to choose robust ones. I bought <a href="https://www.digikey.com/en/products/detail/infineon-technologies/DCMOTORCONTRBTN8982TOBO1/5878319">H-Bridge with BTN8982TA from Digikey</a> and <a href="https://www.amazon.com/s?k=BTS7960B+43A&amp;crid=24E1NQH2DHS0G&amp;sprefix=bts7960b+43a%2Caps%2C134&amp;ref=nb_sb_noss_2">BTS7960B 43A</a> in Amazon. The former proved more reliable and also comes as an Arduino shield, making wiring simpler. The user manual for BTN8982TA board is <a href="https://www.infineon.com/dgdl/Infineon-Motor_Control_Shield_with_BTN8982TA_for_Arduino-UserManual-v02_00-EN.pdf?fileId=5546d4624ca27d02014cb20b89867eed">here</a>.
<br />
<br />
<strong>3. Powersupply</strong>
<br />
A power supply capable of delivering 25V at a minimum of 600 watts is necessary.
<br />
<br />
<strong>4. Control Software</strong>
<br />
The software consists of one GPIO interrupt for the hall effect sensor and two timer interrupts for control loop and pulse length measurement. My initial approach was straightforward: each time the hall effect sensor detected a rising or falling edge, I switched the current direction on the H-bridge driver. This approach allowed me to achieve 60000 RPM with no issues, but higher RPMs were unattainable. Here is my scope capture of V6 motor with this approach.</p>

<p><img src="/assets/h_bridge.jpg" alt="H-Bridge Forward and Backward Current Control" style="display:block; margin-left:auto; margin-right:auto" /></p>
<div align="center">
H-Bridge Forward and Backward Current Control
</div>
<p><br />
<img src="/assets/low_speed.png" alt="The Scope Capture of the Simple Controlling Approach" style="display:block; margin-left:auto; margin-right:auto" /></p>
<div align="center">
The Scope Capture of the Simple Controlling Approach
</div>
<p><br />
Upon observing that enabling the H-bridge before the hall effect sensor’s rising/falling edge boosted speed, this is because the hall effect sensor’s location with respect to the coils. I introduced an adjustable time offset from the previous hall effect sensor edge and enabled H-bridge after this offset. The system remains a closed-loop controlled by the hall effect sensor, however the pulse width control loop is phase-shifted. Now, it is time to reduce pulse width to achieve higher RPMs. A new challenge emerged in getting the minimum pulse width, the timer interrupt service routine measuring pulse durations couldn’t be reduced after some point even when I set the minimum timer period. The problem was the Arduino library <em>digitalWrite(.)/digitalRead(.)</em> functions, which take tens of instruction cycles. I switched to direct GPIO port access to minimize latency in setting GPIOs.</p>

<p><strong>Direct GPIO Port Access Compiled Assembly Code</strong></p>
<pre><code class="language-assembly">  PORTD |= 0b00001000;
     4ae:       5b 9a           sbi     0x0b, 3 ; 11
</code></pre>
<p><br />
<strong>Arduino Library <em>digitalWrite(.)</em> Compiled Assembly Code</strong></p>
<pre><code class="language-assembly">void digitalWrite(uint8_t pin, uint8_t val)
{
        uint8_t timer = digitalPinToTimer(pin);
     476:       e5 e7           ldi     r30, 0x75       ; 117
     478:       f0 e0           ldi     r31, 0x00       ; 0
     47a:       84 91           lpm     r24, Z
        uint8_t bit = digitalPinToBitMask(pin);
     47c:       e1 eb           ldi     r30, 0xB1       ; 177
     47e:       f0 e0           ldi     r31, 0x00       ; 0
     480:       d4 91           lpm     r29, Z
        uint8_t port = digitalPinToPort(pin);
     482:       ed e9           ldi     r30, 0x9D       ; 157
     484:       f0 e0           ldi     r31, 0x00       ; 0
     486:       c4 91           lpm     r28, Z
        volatile uint8_t *out;

        if (port == NOT_A_PIN) return;
     488:       cc 23           and     r28, r28
     48a:       89 f0           breq    .+34            ; 0x4ae &lt;_Z7forwardv+0x3c&gt;

        // If the pin that support PWM output, we need to turn it off
        // before doing a digital write.
        if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     48c:       81 11           cpse    r24, r1
     48e:       0e 94 8c 00     call    0x118   ; 0x118 &lt;turnOffPWM&gt;

        out = portOutputRegister(port);
     492:       ec 2f           mov     r30, r28
     494:       f0 e0           ldi     r31, 0x00       ; 0
     496:       ee 0f           add     r30, r30
     498:       ff 1f           adc     r31, r31
     49a:       ea 57           subi    r30, 0x7A       ; 122
     49c:       ff 4f           sbci    r31, 0xFF       ; 255
     49e:       a5 91           lpm     r26, Z+
     4a0:       b4 91           lpm     r27, Z

        uint8_t oldSREG = SREG;
     4a2:       8f b7           in      r24, 0x3f       ; 63
        cli();
     4a4:       f8 94           cli

        if (val == LOW) {
                *out &amp;= ~bit;
        } else {
                *out |= bit;
     4a6:       ec 91           ld      r30, X
     4a8:       ed 2b           or      r30, r29
     4aa:       ec 93           st      X, r30
        }

        SREG = oldSREG;
     4ac:       8f bf           out     0x3f, r24       ; 63
}
</code></pre>

<p>Following phase shifting from the hall effect detections and GPIO setting optimization, I achieved between 90000 and 120000 RPM for the Dyson DC56(V2), V6, and V10 with the same efficiency as the original models. The Dyson V6 signal capture at 120000 RPM is shown below.</p>

<p><img src="/assets/high_speed.png" alt="120000 RPM in Dyson V6" style="display:block; margin-left:auto; margin-right:auto" /></p>
<div align="center">
120000 RPM in Dyson V6
</div>
<p><br />
My code supports Dyson DC56(V2), V6, and V10 motors. The high-level control loop uses a fixed look-up table for RPM transitions, although it can be converted into a PI control loop.
<br />
<br />
<strong>Some Issues and Tips</strong></p>
<ul>
  <li>The V10 does not ramp-up as smoothly as the original Dyson V10, but the top RPM efficiency is equivalent.</li>
  <li>I recommend using a current limit during the development phase to protect your mosfets, though it will need to be removed to reach high RPMs.</li>
  <li>Avoid running the system excessively without proper cooling. The best cooling location is behind the motor, providing ample airflow. Position the H-bridge circuitry output of the airflow.</li>
</ul>

<p>For up-to-date code, you can check the repo <a href="https://github.com/hasanunlu/dyson_motor_controller">here</a>.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define HALL_EFFECT 2
</span>
<span class="c1">// H-Bridge Arduino Shield with BTN8982TA</span>
<span class="cp">#define R_INH 12
#define L_INH 13
#define R_IN   3
#define L_IN  11
#define R_IS  A0
#define L_IS  A1
</span>
<span class="c1">// CURRENT_LIMIT_ANALOG_COUNTER / 1023 * 5 * 19.5A = I_LIMIT</span>
<span class="cp">#define CURRENT_LIMIT_ANALOG_COUNTER      1000 
#define ENABLE_CURRENT_LIMIT_CHECK        false
</span>
<span class="cp">#define REF_CYCLE_FROM_DISABLE_TO_ENABLE  8
</span>
<span class="c1">// #define DYSON_V2</span>
<span class="c1">// #define DYSON_V6</span>
<span class="cp">#define DYSON_V10
</span>
<span class="kt">void</span> <span class="nf">disable_driver</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// digitalWrite(R_INH, 0);</span>
  <span class="c1">// digitalWrite(L_INH, 0);</span>
  <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="mb">0b11001111</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">enable_driver</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// digitalWrite(R_INH, 1);</span>
  <span class="c1">// digitalWrite(L_INH, 1);</span>
  <span class="n">PORTB</span> <span class="o">|=</span> <span class="mb">0b00110000</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">forward</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// digitalWrite(R_IN, 1);</span>
  <span class="c1">// digitalWrite(L_IN, 0);</span>
  <span class="n">PORTD</span> <span class="o">|=</span> <span class="mb">0b00001000</span><span class="p">;</span>
  <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="mb">0b11110111</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">reverse</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// digitalWrite(R_IN, 0);</span>
  <span class="c1">// digitalWrite(L_IN, 1);</span>
  <span class="n">PORTD</span> <span class="o">&amp;=</span> <span class="mb">0b11110111</span><span class="p">;</span>
  <span class="n">PORTB</span> <span class="o">|=</span> <span class="mb">0b00001000</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">head_start</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Poking</span>
  <span class="n">reverse</span><span class="p">();</span>
  <span class="n">delayMicroseconds</span><span class="p">(</span><span class="mi">4000</span><span class="p">);</span>
  <span class="n">forward</span><span class="p">();</span>
  <span class="n">delayMicroseconds</span><span class="p">(</span><span class="mi">4000</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">HALL_EFFECT</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">reverse</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">forward</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">delayMicroseconds</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define FIRST_STATE 0
</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">early_pulse_cycles</span><span class="p">[]</span>
<span class="p">{</span>
<span class="cp">#ifdef DYSON_V10
</span>  <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="n">REF_CYCLE_FROM_DISABLE_TO_ENABLE</span><span class="p">,</span>
  <span class="n">REF_CYCLE_FROM_DISABLE_TO_ENABLE</span><span class="p">,</span>
  <span class="n">REF_CYCLE_FROM_DISABLE_TO_ENABLE</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span>
  <span class="n">REF_CYCLE_FROM_DISABLE_TO_ENABLE</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span>
  <span class="n">REF_CYCLE_FROM_DISABLE_TO_ENABLE</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span>
  <span class="n">REF_CYCLE_FROM_DISABLE_TO_ENABLE</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span>
  <span class="n">REF_CYCLE_FROM_DISABLE_TO_ENABLE</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
<span class="cp">#elif defined(DYSON_V6)
</span>  <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="n">REF_CYCLE_FROM_DISABLE_TO_ENABLE</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span>
  <span class="n">REF_CYCLE_FROM_DISABLE_TO_ENABLE</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
  <span class="n">REF_CYCLE_FROM_DISABLE_TO_ENABLE</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span>
<span class="cp">#elif defined(DYSON_V2)
</span>  <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="n">REF_CYCLE_FROM_DISABLE_TO_ENABLE</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
  <span class="n">REF_CYCLE_FROM_DISABLE_TO_ENABLE</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
<span class="cp">#endif
</span><span class="p">};</span>

<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">pulse_cycle_arr</span><span class="p">[]</span>
<span class="p">{</span>
<span class="cp">#ifdef DYSON_V10
</span>  <span class="mi">170</span><span class="p">,</span>
  <span class="mi">130</span><span class="p">,</span>
   <span class="mi">60</span><span class="p">,</span>
   <span class="mi">42</span><span class="p">,</span>
   <span class="mi">24</span><span class="p">,</span>
   <span class="mi">15</span><span class="p">,</span>
   <span class="mi">13</span><span class="p">,</span>
   <span class="mi">10</span><span class="p">,</span>
   <span class="mi">6</span><span class="p">,</span>
   <span class="mi">3</span><span class="p">,</span>
   <span class="mi">1</span><span class="p">,</span>
   <span class="mi">1</span><span class="p">,</span>
   <span class="mi">1</span><span class="p">,</span>
<span class="cp">#elif defined(DYSON_V6)
</span>  <span class="mi">150</span><span class="p">,</span>
   <span class="mi">42</span><span class="p">,</span>
   <span class="mi">24</span><span class="p">,</span>
   <span class="mi">19</span><span class="p">,</span>
   <span class="mi">13</span><span class="p">,</span>
   <span class="mi">9</span><span class="p">,</span>
<span class="cp">#elif defined(DYSON_V2)
</span>  <span class="mi">100</span><span class="p">,</span>
   <span class="mi">45</span><span class="p">,</span>
   <span class="mi">34</span><span class="p">,</span>
   <span class="mi">25</span><span class="p">,</span>
   <span class="mi">25</span><span class="p">,</span>
<span class="cp">#endif
</span><span class="p">};</span>

<span class="k">const</span> <span class="kt">float</span> <span class="n">rpm_thresholds</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span>
<span class="p">{</span>
<span class="cp">#ifdef DYSON_V10
</span>  <span class="p">{</span>   <span class="mf">0.</span><span class="n">f</span><span class="p">,</span>     <span class="mf">300.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span> <span class="mf">700.</span><span class="n">f</span><span class="p">,</span>    <span class="mf">1200.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span> <span class="mf">2000.</span><span class="n">f</span><span class="p">,</span>   <span class="mf">5000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span> <span class="mf">3750.</span><span class="n">f</span><span class="p">,</span>   <span class="mf">7500.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span> <span class="mf">5000.</span><span class="n">f</span><span class="p">,</span>  <span class="mf">14000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">12000.</span><span class="n">f</span><span class="p">,</span>  <span class="mf">20000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">22000.</span><span class="n">f</span><span class="p">,</span>  <span class="mf">30000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">25000.</span><span class="n">f</span><span class="p">,</span>  <span class="mf">40000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">35000.</span><span class="n">f</span><span class="p">,</span>  <span class="mf">50000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">45000.</span><span class="n">f</span><span class="p">,</span>  <span class="mf">70000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">60000.</span><span class="n">f</span><span class="p">,</span>  <span class="mf">85000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">70000.</span><span class="n">f</span><span class="p">,</span>  <span class="mf">90000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">70000.</span><span class="n">f</span><span class="p">,</span> <span class="mf">140000.</span><span class="n">f</span><span class="p">},</span>
<span class="cp">#elif defined(DYSON_V6)
</span>  <span class="p">{</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span>       <span class="mf">10000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">7500.</span><span class="n">f</span><span class="p">,</span>    <span class="mf">15000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">10000.</span><span class="n">f</span><span class="p">,</span>   <span class="mf">35000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">30000.</span><span class="n">f</span><span class="p">,</span>   <span class="mf">65000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">60000.</span><span class="n">f</span><span class="p">,</span>   <span class="mf">80000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">70000.</span><span class="n">f</span><span class="p">,</span>  <span class="mf">140000.</span><span class="n">f</span><span class="p">},</span>
<span class="cp">#elif defined(DYSON_V2)
</span>  <span class="p">{</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span>      <span class="mf">20000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">15000.</span><span class="n">f</span><span class="p">,</span>  <span class="mf">30000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">20000.</span><span class="n">f</span><span class="p">,</span>  <span class="mf">70000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">60000.</span><span class="n">f</span><span class="p">,</span> <span class="mf">100000.</span><span class="n">f</span><span class="p">},</span>
  <span class="p">{</span><span class="mf">80000.</span><span class="n">f</span><span class="p">,</span> <span class="mf">150000.</span><span class="n">f</span><span class="p">}</span>
<span class="cp">#endif
</span><span class="p">};</span>

<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">state</span> <span class="o">=</span> <span class="n">FIRST_STATE</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">float</span> <span class="n">speed</span> <span class="o">=</span> <span class="mf">0.</span><span class="n">f</span><span class="p">;</span> <span class="c1">// in RPM</span>
<span class="k">volatile</span> <span class="kt">bool</span> <span class="n">hall_value</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">bool</span> <span class="n">early_pulse_enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">forward_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">reverse_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">forward_cnt_happenned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">reverse_cnt_happenned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">inhibit_cnt_forward</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">inhibit_cnt_reverse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">pulse_duration</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">early_pulse_cnt_from_inhibit</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">disable_to_hall_effect</span><span class="p">;</span>

<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time_rising</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time_falling</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_time_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_time_low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 
<span class="kt">void</span> <span class="n">hall_effect_int</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">early_pulse_enable</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">enable_driver</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// hall_value = digitalRead(HALL_EFFECT);</span>
  <span class="n">hall_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIND</span> <span class="o">&amp;</span> <span class="mb">0b00000100</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">hall_value</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">time_rising</span> <span class="o">=</span> <span class="n">micros</span><span class="p">();</span>
    <span class="n">delta_time_high</span> <span class="o">=</span> <span class="n">time_rising</span> <span class="o">-</span> <span class="n">time_falling</span><span class="p">;</span>
    <span class="n">forward_cnt_happenned</span> <span class="o">=</span> <span class="n">forward_cnt</span><span class="p">;</span>
    <span class="n">forward_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">inhibit_cnt_forward</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">time_falling</span> <span class="o">=</span> <span class="n">micros</span><span class="p">();</span>
    <span class="n">delta_time_low</span> <span class="o">=</span> <span class="n">time_falling</span> <span class="o">-</span> <span class="n">time_rising</span><span class="p">;</span>
    <span class="n">reverse_cnt_happenned</span> <span class="o">=</span> <span class="n">reverse_cnt</span><span class="p">;</span>
    <span class="n">reverse_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">inhibit_cnt_reverse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Measures number of cycles between driver-off and hall effect sensor change</span>
    <span class="n">disable_to_hall_effect</span> <span class="o">=</span> <span class="n">inhibit_cnt_forward</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">ISR</span><span class="p">(</span><span class="n">TIMER1_COMPA_vect</span><span class="p">){</span>
  <span class="n">TCNT1</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Clear for every interrupt</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">hall_value</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">forward_cnt</span> <span class="o">&gt;=</span> <span class="n">pulse_duration</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">inhibit_cnt_forward</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">disable_driver</span><span class="p">();</span>
        <span class="n">reverse</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="n">inhibit_cnt_forward</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">forward_cnt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">early_pulse_enable</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">inhibit_cnt_forward</span> <span class="o">==</span> <span class="n">early_pulse_cnt_from_inhibit</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">enable_driver</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">reverse_cnt</span> <span class="o">&gt;=</span> <span class="n">pulse_duration</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">inhibit_cnt_reverse</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">disable_driver</span><span class="p">();</span>
        <span class="n">forward</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="n">inhibit_cnt_reverse</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">reverse_cnt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">early_pulse_enable</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">inhibit_cnt_reverse</span> <span class="o">==</span> <span class="n">early_pulse_cnt_from_inhibit</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">enable_driver</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">ISR</span><span class="p">(</span><span class="n">TIMER2_COMPA_vect</span><span class="p">){</span>
  <span class="n">TCNT2</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Clear for every interrupt</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="mi">25</span><span class="p">)</span> <span class="c1">// 25 * 10ms = 250ms</span>
  <span class="p">{</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
    <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="n">rpm_thresholds</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">{</span>
      <span class="n">state</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  
    <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="n">rpm_thresholds</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="p">{</span>
      <span class="n">state</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Update pulse control parameters</span>
    <span class="n">pulse_duration</span> <span class="o">=</span> <span class="n">pulse_cycle_arr</span><span class="p">[</span><span class="n">state</span><span class="p">];</span>
    <span class="n">early_pulse_cnt_from_inhibit</span> <span class="o">=</span>  <span class="n">early_pulse_cycles</span><span class="p">[</span><span class="n">state</span><span class="p">];</span>
    <span class="n">early_pulse_enable</span> <span class="o">=</span> <span class="n">early_pulse_cycles</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">setup</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
  
    <span class="n">pinMode</span><span class="p">(</span><span class="n">HALL_EFFECT</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">HALL_EFFECT</span><span class="p">,</span> <span class="n">INPUT_PULLUP</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">R_IS</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">L_IS</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">R_INH</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">L_INH</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">R_IN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">L_IN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>

    <span class="n">disable_driver</span><span class="p">();</span>

    <span class="n">cli</span><span class="p">();</span>

    <span class="n">attachInterrupt</span><span class="p">(</span><span class="n">digitalPinToInterrupt</span><span class="p">(</span><span class="n">HALL_EFFECT</span><span class="p">),</span> <span class="n">hall_effect_int</span><span class="p">,</span> <span class="n">CHANGE</span><span class="p">);</span>
  
    <span class="c1">// Timer 1</span>
    <span class="n">TCCR1A</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Reset entire TCCR1A to 0 </span>
    <span class="n">TCCR1B</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Reset entire TCCR1B to 0</span>
    <span class="n">TCNT1</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Clear timer1 counter</span>
  
    <span class="c1">// Compare A</span>
    <span class="n">TCCR1B</span> <span class="o">|=</span> <span class="n">B00000010</span><span class="p">;</span> <span class="c1">// CS12 CS11 CS10 -&gt; 010 -&gt; CLK / 8</span>
    <span class="n">TIMSK1</span> <span class="o">|=</span> <span class="n">B00000010</span><span class="p">;</span> <span class="c1">// Set OCIE1A 1 -&gt; compare match for A</span>
    <span class="n">OCR1A</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// 16 MHz / 8 / 12 -&gt; 6us</span>
  
    <span class="c1">// Timer 2</span>
    <span class="n">TCCR2A</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Reset entire TCCR2A to 0 </span>
    <span class="n">TCCR2B</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Reset entire TCCR2B to 0</span>

    <span class="c1">// Compare A</span>
    <span class="n">TCCR2B</span> <span class="o">|=</span> <span class="n">B00000101</span><span class="p">;</span> <span class="c1">// CS12 CS11 CS10 -&gt; 101 -&gt; CLK / 1024 </span>
    <span class="n">TIMSK2</span> <span class="o">|=</span> <span class="n">B00000010</span><span class="p">;</span> <span class="c1">//Set OCIE1A to 1 -&gt; compare match for A</span>
    <span class="n">OCR2A</span> <span class="o">=</span> <span class="mi">157</span><span class="p">;</span> <span class="c1">// 16 MHz / 1024 / 157 -&gt; ~10 ms</span>

    <span class="n">enable_driver</span><span class="p">();</span>
    <span class="n">head_start</span><span class="p">();</span>

    <span class="c1">// Initial condition setup</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">FIRST_STATE</span><span class="p">;</span>
    <span class="n">pulse_duration</span> <span class="o">=</span> <span class="n">pulse_cycle_arr</span><span class="p">[</span><span class="n">FIRST_STATE</span><span class="p">];</span>
    <span class="n">early_pulse_cnt_from_inhibit</span> <span class="o">=</span>  <span class="n">early_pulse_cycles</span><span class="p">[</span><span class="n">FIRST_STATE</span><span class="p">];</span>
    <span class="n">early_pulse_enable</span> <span class="o">=</span> <span class="n">early_pulse_cycles</span><span class="p">[</span><span class="n">FIRST_STATE</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
  
    <span class="n">sei</span><span class="p">();</span> <span class="c1">// Enable back the interrupts</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">float</span> <span class="n">period_time</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="n">delta_time_high</span> <span class="o">+</span> <span class="n">delta_time_low</span><span class="p">);</span>

<span class="cp">#ifdef DYSON_V10 // 8 poles, single phase
</span>  <span class="n">speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">period_time</span> <span class="o">!=</span> <span class="mf">0.</span><span class="n">f</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="mf">15.</span><span class="n">f</span> <span class="o">*</span> <span class="mf">1000000.</span><span class="n">f</span> <span class="o">/</span> <span class="n">period_time</span><span class="p">)</span> <span class="o">:</span> <span class="mf">0.</span><span class="n">f</span><span class="p">;</span>
<span class="cp">#elif defined(DYSON_V6) // 4 poles, single phase
</span>  <span class="n">speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">period_time</span> <span class="o">!=</span> <span class="mf">0.</span><span class="n">f</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="mf">30.</span><span class="n">f</span> <span class="o">*</span> <span class="mf">1000000.</span><span class="n">f</span> <span class="o">/</span> <span class="n">period_time</span><span class="p">)</span> <span class="o">:</span> <span class="mf">0.</span><span class="n">f</span><span class="p">;</span>
<span class="cp">#elif defined(DYSON_V2) // 2 poles, single phase
</span>  <span class="n">speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">period_time</span> <span class="o">!=</span> <span class="mf">0.</span><span class="n">f</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="mf">60.</span><span class="n">f</span> <span class="o">*</span> <span class="mf">1000000.</span><span class="n">f</span> <span class="o">/</span> <span class="n">period_time</span><span class="p">)</span> <span class="o">:</span> <span class="mf">0.</span><span class="n">f</span><span class="p">;</span>
<span class="cp">#endif
</span>
  <span class="c1">// These are custom inputs for debugging</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="n">data</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="sc">'a'</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">pulse_duration</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="sc">'z'</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">pulse_duration</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="sc">'w'</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">early_pulse_cnt_from_inhibit</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="sc">'q'</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">early_pulse_cnt_from_inhibit</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="sc">'e'</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">early_pulse_enable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="sc">'s'</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">cli</span><span class="p">();</span>
      <span class="n">disable_driver</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">is_r</span> <span class="o">=</span> <span class="n">analogRead</span><span class="p">(</span><span class="n">R_IS</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">is_l</span> <span class="o">=</span> <span class="n">analogRead</span><span class="p">(</span><span class="n">L_IS</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ENABLE_CURRENT_LIMIT_CHECK</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">is_r</span> <span class="o">&gt;</span> <span class="n">CURRENT_LIMIT_ANALOG_COUNTER</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">is_l</span> <span class="o">&gt;</span> <span class="n">CURRENT_LIMIT_ANALOG_COUNTER</span><span class="p">)))</span>
  <span class="p">{</span>
    <span class="n">cli</span><span class="p">();</span>
    <span class="n">disable_driver</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">" speed: "</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">speed</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">" RPM"</span><span class="p">);</span>
  
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">" state: "</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>

  <span class="c1">// Serial.print("high: ");</span>
  <span class="c1">// Serial.print(delta_time_high);</span>
  <span class="c1">// Serial.print(" low: ");</span>
  <span class="c1">// Serial.print(delta_time_low);</span>

  <span class="c1">// Serial.print(" forward_cnt: ");</span>
  <span class="c1">// Serial.print(forward_cnt_happenned);</span>
  <span class="c1">// Serial.print(" reverse_cnt: ");</span>
  <span class="c1">// Serial.print(reverse_cnt_happenned);</span>

  <span class="c1">// Serial.print(" disable_to_hall_effect: ");</span>
  <span class="c1">// Serial.print(disable_to_hall_effect);</span>
  <span class="c1">// Serial.print(" is_r: ");</span>
  <span class="c1">// Serial.print(is_r);</span>
  <span class="c1">// Serial.print(" is_l: ");</span>
  <span class="c1">// Serial.print(is_l);</span>
  <span class="c1">// Serial.print(" pulse_duration: ");</span>
  <span class="c1">// Serial.print(pulse_duration);</span>
  <span class="c1">// Serial.print(" early_pulse_enable: ");</span>
  <span class="c1">// Serial.print(early_pulse_enable);</span>
  <span class="c1">// Serial.print(" early_pulse_cnt_from_inhibit: ");</span>
  <span class="c1">// Serial.println(early_pulse_cnt_from_inhibit);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[Dyson V6 Setup Dyson V10 Setup Dyson handheld vacuum cleaners utilize high RPM brushless DC motors. Specifications indicate that some models can reach as high as 125000 RPM. I’ve disassembled DC56(V2), V6, and V10 models. Each has a brushless single-phase motor, with differing number of poles: two for the DC56, four for the V6, and eight for the V10. An earlier article about their DC56(V2) motor hinted that besides the mechanical design, the controlling software is the key. The electronics are relatively straightforward, including an H-bridge driver, microcontroller, and hall effect sensor. I’ve taken up the task and developed my own software to match Dyson’s factory performance. My software could potentially be used with all their brushless motors. The components I utilized include an Arduino Uno (8-bit ATmega328P microcontroller), H-bridge controller, and a hall effect sensor. Despite Dyson V10 employing a 32-bit ARM micro-controller, I managed to control it using an 8-bit Arduino, which is cheaper component.]]></summary></entry><entry><title type="html">Expanding Quake’s Famous Fast Inverse Square Root Algorithm</title><link href="http://localhost:4000/2023/04/09/Expanding-Quake-s-Famous-Fast-Inverse-Sqrt-Root-Algorithm.html" rel="alternate" type="text/html" title="Expanding Quake’s Famous Fast Inverse Square Root Algorithm" /><published>2023-04-09T10:46:39-07:00</published><updated>2023-04-09T10:46:39-07:00</updated><id>http://localhost:4000/2023/04/09/Expanding-Quake-s-Famous-Fast-Inverse-Sqrt-Root-Algorithm</id><content type="html" xml:base="http://localhost:4000/2023/04/09/Expanding-Quake-s-Famous-Fast-Inverse-Sqrt-Root-Algorithm.html"><![CDATA[<p>In 1999, an unintuitive method was employed in the Quake III Arena graphics library to quickly calculate surface normals for lighting and shading. The function calculating inverse square root is in below. The original code for the repository can be found <a href="https://archive.softwareheritage.org/browse/content/sha1_git:bb0faf6919fc60636b2696f32ec9b3c2adb247fe/?origin_url=https://github.com/id-Software/Quake-III-Arena&amp;path=code/game/q_math.c&amp;revision=dbe4ddb10315479fc00086f08e25d968b4b43c49&amp;snapshot=4ab9bcef131aaf449a7c01370aff8c91dcecbf5f#L549-L572">here</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">Q_rsqrt</span><span class="p">(</span> <span class="kt">float</span> <span class="n">number</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">float</span> <span class="n">threehalfs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="n">F</span><span class="p">;</span>

	<span class="n">x2</span> <span class="o">=</span> <span class="n">number</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">F</span><span class="p">;</span>
	<span class="n">y</span>  <span class="o">=</span> <span class="n">number</span><span class="p">;</span>
	<span class="n">i</span>  <span class="o">=</span> <span class="o">*</span> <span class="p">(</span> <span class="kt">long</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>                       <span class="c1">// evil floating point bit level hacking</span>
	<span class="n">i</span>  <span class="o">=</span> <span class="mh">0x5f3759df</span> <span class="o">-</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="p">);</span>               <span class="c1">// what the fuck? </span>
	<span class="n">y</span>  <span class="o">=</span> <span class="o">*</span> <span class="p">(</span> <span class="kt">float</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
	<span class="n">y</span>  <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span> <span class="n">threehalfs</span> <span class="o">-</span> <span class="p">(</span> <span class="n">x2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="p">)</span> <span class="p">);</span>   <span class="c1">// 1st iteration</span>
<span class="c1">//	y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed</span>

	<span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The advantage stems from the way numbers are stored in floating-point format like $x=\pm(1+m_x)2^{e_x}$, which allows power operations to be converted into addition and subtraction in the exponent field. Also $log_2(1+x)\approx x$ in the mantissa field. This assists in finding an initial approximation, with one or two Newton-Raphson iterations yielding highly accurate results for compute heavy functions, such as the inverse square root.
<br />
<br />
<img src="/assets/ieee754_float.png" alt="IEEE 754 Single-Precision Format" style="display:block; margin-left:auto; margin-right:auto" /></p>
<div align="center">
IEEE 754 Single-Precision Format
</div>
<p><br />
<br />
In this article, I will derive a generic formula and code to apply this method for computing $x^{\frac{1}{m}}$ where $m \in Z$ and $m \neq 0$.
<br />
<br />
<strong>First Step: Deriving Magic Number and Initial Guess</strong>
<br />
Let’s represent the floating-point number in its integer-casted form. For the time being, assume all values are positive, which means the sign bit is zero.
<br />
<br />
$I_x = E_x \cdot L + M_x$ where $L=2^{23}$ for single precision floating point format.
<br />
<br />
The floating point number’s value representaion: 
<br />
<br />
$x = (1 + \frac{M_x}{L})\cdot 2^{E_x - B}$ where $B=127$ for single precision floating point format.
<br />
<br />
Now we need to represent $I_x$ in terms of $x$. However dealing with $x$ in this form is not easy. Let’s take $log_2$ of both side.
<br />
<br />
$log_2 x = log_2 (1 + \frac{M_x}{L}) + E_x - B$, we know that $\frac{M_x}{L} &lt; 1$.
<br />
<br />
$log_2 x \approx \frac{M_x}{L} + \sigma + E_x - B$ where $\sigma$ is such constant to improve approximation accuracy. In the step three, we will calculate $\sigma$. Please also check $log(1+x) \approx x$ for near zero values.
<br />
<br />
$log_2 x \approx  \frac{M_x}{L}  + \sigma + E_x - B$, subsitue $M_x$ with $I_x -  E_x \cdot L$
<br />
<br />
$log_2 x \approx \frac{I_x -  E_x \cdot L}{L}  + \sigma + E_x - B$
<br />
<br />
$log_2 x \approx \frac{I_x}{L} - E_x  + \sigma + E_x - B$
<br />
<br />
$log_2 x \approx \frac{I_x}{L} + \sigma - B$
<br />
<br />
The value we are trying to find is $y = x^{\frac{1}{m}}$.
<br />
<br />
$log_2 y \approx \frac{I_y}{L} + \sigma - B$
<br />
<br />
At the same time, $log_2 y = log_2 x^{\frac{1}{m}}$
<br />
<br />
$log_2 y = \frac{1}{m}log_2 x$
<br />
<br />
$\frac{I_y}{L} + \sigma - B \approx \frac{1}{m}(\frac{I_x}{L} + \sigma - B)$
<br />
<br />
$\frac{I_y}{L} \approx \frac{I_x}{m\cdot L} + (\frac{1}{m} - 1)(\sigma - B)$
<br />
<br />
$I_y \approx \frac{I_x}{m} + L(\frac{1}{m} - 1)(\sigma - B)$
<br />
<br />
$I_y \approx \frac{I_x}{m} + (1 - \frac{1}{m})L(B - \sigma)$
<br />
<br />
In here $(1 - \frac{1}{m})L(B - \sigma)$ corresponds magic number where $L=2^{23}$ and $B=127$ for IEEE 754 single precision format.
<br />
<br />
<strong>Second Step: Newton-Raphson Method</strong>
<br />
We need to find the $1/m$ power of a number, so if we define this as an unknown, the problem can be formulated as follows:
<br />
<br />
$f(x) = x^{m} - a$ to find a root of this function which is $a^{\frac{1}{m}}$
<br />
<br />
The Newthon-Raphson iteration for this $f(x)$ would be
<br />
<br />
$x_{n+1} = x_n - \frac{f(x_n)}{f’(x_n)}$
<br />
<br />
$x_{n+1} = x_n - \frac{x_n^m - a}{m\cdot x_n^{m-1}}$
<br />
<br />
$x_{n+1} = x_n - \frac{1}{m}(x_n - a \cdot x_n^{1-m})$
<br />
<br />
$x_{n+1} = \frac{(m - 1) \cdot x_n + a \cdot x_n^{1-m}}{m}$
<br />
<br />
$x_{n+1} = \frac{x_n \cdot ( m - 1 + a \cdot x_n^{-m})}{m}$
<br />
<br />
<strong>Third Step: Finding $\sigma$</strong>
<br />
There are several approaches to finding it. In this case, we will focus on minimizing the maximum error for any given value within the $[0, 1]$ interval. The error function can be defined as $|log_2 (x+1) - (x+\sigma)|$. This function has one local maximum and two interval edge points. The error amounts at the interval boundaries (at $0$ and $1$) are both equal to $\sigma$.
<br />
<br />
<img src="/assets/error_graph.png" alt="Error Graph" style="display:block; margin-left:auto; margin-right:auto" /></p>
<div align="center">
Logx, x and Relative Error Graph
</div>
<p><br />
Check Desmos graphing calculator <a href="https://www.desmos.com/calculator/gizsi2hjz3">here</a> to edit and play with approxmation variable.
<br />
<br />
We need to get the derivative to find local maxima.
<br />
<br />
$\frac{\partial error(x)}{\partial x}=\frac{1}{ln(2)*(x+1)} - 1 = 0$
<br />
<br />
$x=1 - \frac{1}{ln(2)} = 0.44269504088$
<br />
<br />
The error value at this local maxima should not exceed the error amounts at the boundaries.
<br />
<br />
$log_2 (x+1) - (x+\sigma)=\sigma$ where $x=0.44269504088$.
<br />
<br />
$log_2(0.44269504088 + 1) - 0.44269504088 = 2\sigma$
<br />
<br />
$\sigma = (log_2(1.44269504088) - 0.44269504088)/2$
<br />
<br />
$\sigma = 0.04303566602$
<br />
<br />
Here is the generic code for taking power of $1/m$. You can modify and optimize it for specific $m$ values as needed.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Fast_1_M_Math</span>
<span class="p">{</span>
    <span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">magic_number</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">integer_power</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">power</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">result</span> <span class="o">=</span> <span class="mf">1.</span><span class="n">f</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">power</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">power</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">power</span> <span class="o">=</span> <span class="n">power</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">power</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nl">public:</span>

    <span class="n">Fast_1_M_Math</span><span class="p">(</span><span class="kt">int</span> <span class="n">m_number</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.04303566602</span><span class="p">;</span> <span class="c1">// Approximation constant</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="n">B</span> <span class="o">=</span> <span class="mf">127.</span><span class="n">f</span><span class="p">;</span> <span class="c1">// IEEE-754 single precision exponent offset</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="n">L</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">;</span> <span class="c1">// IEEE-754 single prrecision mantissa length</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m_number</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">partial</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="n">m_number</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">;</span>
    	<span class="n">magic_number</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">partial</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="n">get</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
       	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">((</span><span class="n">m</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="n">f</span><span class="p">))</span>
       	<span class="p">{</span>
        	<span class="k">return</span> <span class="n">NAN</span><span class="p">;</span>
       	<span class="p">}</span>

       	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
       	<span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">m</span> <span class="o">+</span> <span class="n">magic_number</span><span class="p">;</span>
       	<span class="kt">float</span> <span class="n">x_n</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>

    	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    	<span class="p">{</span>
            <span class="c1">// One iteration Newton-Raphson</span>
            <span class="k">return</span> <span class="n">x_n</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">/</span> <span class="n">integer_power</span><span class="p">(</span><span class="n">x_n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span> <span class="o">/</span> <span class="n">m</span><span class="p">;</span> 
    	<span class="p">}</span>
       	<span class="k">else</span>
       	<span class="p">{</span>
            <span class="c1">// One iteration Newton-Raphson</span>
            <span class="k">return</span> <span class="n">x_n</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">integer_power</span><span class="p">(</span><span class="n">x_n</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">))</span> <span class="o">/</span> <span class="n">m</span><span class="p">;</span>
       	<span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Fast_1_M_Math</span> <span class="n">inverse_square</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>

    <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">1123.4231231</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">inverse_square</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">a2</span> <span class="o">=</span>  <span class="mf">1.</span><span class="n">f</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"fast: "</span> <span class="o">&lt;&lt;</span> <span class="n">a1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"lib: "</span> <span class="o">&lt;&lt;</span> <span class="n">a2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br />
<strong>Expanding it to Exponential Function</strong>
<br />
If we set our function as $y = 2^x$. We get $log_2 y = log_2 2^x$.
<br />
<br />
Logarithm cancels out. $log_2 y = x$
<br />
<br />
We know that $log_2 y \approx \frac{I_y}{L} + \sigma - B$
<br />
<br />
$x \approx \frac{I_y}{L} + \sigma - B$
<br />
<br />
$I_y \approx L*(x-\sigma+B)$
<br />
<br />
Newton-Raphson method would be useful for one more level of accuracy, however the iteration step requires logarithm so it isn’t cheap to calculate.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">fastPowerOfTwo</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.04303566602</span><span class="p">;</span> <span class="c1">// Approximation constant</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">B</span> <span class="o">=</span> <span class="mf">127.</span><span class="n">f</span><span class="p">;</span> <span class="c1">// IEEE-754 single precision exponent offset</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">L</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">;</span> <span class="c1">// IEEE-754 single prrecision mantissa length</span>
    
    <span class="c1">// Need to deal with overflows in exponent region</span>
    <span class="kt">float</span> <span class="n">fractional_exponent</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">+</span> <span class="n">B</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fractional_exponent</span> <span class="o">&gt;</span> <span class="mf">255.</span><span class="n">f</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fractional_exponent</span> <span class="o">=</span> <span class="mf">255.</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="n">I_y</span> <span class="o">=</span> <span class="n">L</span> <span class="o">*</span> <span class="n">fractional_exponent</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">I_y</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">I</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br />
The popular function in general is natural exponent function. Base two can be converted into natural exponent using the following base change rule.
<br />
$e^x = 2^{\frac{x}{ln(2)}}$</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">fastExp</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">one_over_ln2</span> <span class="o">=</span> <span class="mf">1.44269504089</span><span class="n">f</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.04303566602</span><span class="p">;</span> <span class="c1">// Approximation constant</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">B</span> <span class="o">=</span> <span class="mf">127.</span><span class="n">f</span><span class="p">;</span> <span class="c1">// IEEE-754 single precision exponent offset</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">L</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">;</span> <span class="c1">// IEEE-754 single prrecision mantissa length</span>

    <span class="c1">// Need to deal with overflows in exponent region</span>
    <span class="kt">float</span> <span class="n">fractional_exponent</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">one_over_ln2</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">+</span> <span class="n">B</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fractional_exponent</span> <span class="o">&gt;</span> <span class="mf">255.</span><span class="n">f</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fractional_exponent</span> <span class="o">=</span> <span class="mf">255.</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">float</span> <span class="n">I_y</span> <span class="o">=</span> <span class="n">L</span> <span class="o">*</span> <span class="n">fractional_exponent</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">I_y</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">I</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>References</strong></p>
<ul>
  <li>Lomont, Chris (February 2003). “Fast Inverse Square Root” (PDF). Retrieved 2009-02-13.</li>
  <li>https://en.wikipedia.org/wiki/Fast_inverse_square_root</li>
</ul>]]></content><author><name></name></author><summary type="html"><![CDATA[In 1999, an unintuitive method was employed in the Quake III Arena graphics library to quickly calculate surface normals for lighting and shading. The function calculating inverse square root is in below. The original code for the repository can be found here.]]></summary></entry><entry><title type="html">Trying to Understand Irrational Numbers Using a Rational Way</title><link href="http://localhost:4000/2023/03/17/Trying-to-Understand-Irrational-Numbers-Using-a-Rational-Method.html" rel="alternate" type="text/html" title="Trying to Understand Irrational Numbers Using a Rational Way" /><published>2023-03-17T21:46:39-07:00</published><updated>2023-03-17T21:46:39-07:00</updated><id>http://localhost:4000/2023/03/17/Trying-to-Understand-Irrational-Numbers-Using-a-Rational-Method</id><content type="html" xml:base="http://localhost:4000/2023/03/17/Trying-to-Understand-Irrational-Numbers-Using-a-Rational-Method.html"><![CDATA[<p>Most people enjoy playing Jenga. Picture yourself in a room filled with an infinite number of identical Jenga blocks, disregarding their depth.</p>

<p><img src="/assets/jenga.png" alt="Jenga blocks" style="display:block; margin-left:auto; margin-right:auto" /></p>
<div align="center">
Jenga blocks
</div>
<p><br />
You become curious about the length-to-width ratio of a Jenga block but lack any measuring tools. Nevertheless, you devise a method to determine this ratio by arranging the blocks vertically and horizontally.</p>

<p><img src="/assets/ratio.png" alt="A solution finding length-to-width ratio" style="display:block; margin-left:auto; margin-right:auto" /></p>
<div align="center">
A solution finding length-to-width ratio
</div>
<p><br />
To find the length-to-width ratio, you count the number of vertical and horizontal blocks used once they align (vertical blocks / horizontal blocks).</p>

\[\frac{\textrm{number of vertical blocks}}{\textrm{number of horizontal blocks}} = \frac{l}{w}\]

<p>However, you observe that these Jenga blocks never truly align, only coming closer to alignment. You wonder what is unique about their length-to-width ratio.</p>

<p><strong>The answer is that the ratio is an irrational number.</strong></p>

<p>To represent an irrational number, you would need an infinite number of blocks, as it is impossible to represent such a number within a finite domain. The length-to-width ratio is a real value in your hand, yet it cannot be represented in a finite world. Irrational numbers like $\sqrt{2}$ and $\pi$ are merely symbols that indicate their existence.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Most people enjoy playing Jenga. Picture yourself in a room filled with an infinite number of identical Jenga blocks, disregarding their depth.]]></summary></entry><entry><title type="html">Running LeNet-5 on RISC-V Micro-Controller with only 16 KBytes Memory</title><link href="http://localhost:4000/2020/06/10/Running-LeNet-5-on-RISC-V-Micro-Controller-with-only-16-KBytes-Memory.html" rel="alternate" type="text/html" title="Running LeNet-5 on RISC-V Micro-Controller with only 16 KBytes Memory" /><published>2020-06-10T21:46:39-07:00</published><updated>2020-06-10T21:46:39-07:00</updated><id>http://localhost:4000/2020/06/10/Running-LeNet-5-on-RISC-V-Micro-Controller-with-only-16-KBytes-Memory</id><content type="html" xml:base="http://localhost:4000/2020/06/10/Running-LeNet-5-on-RISC-V-Micro-Controller-with-only-16-KBytes-Memory.html"><![CDATA[<div class="video-holder">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/nQN_5fDQbI4" frameborder="0" allowfullscreen=""></iframe>
</div>
<p><br />
<img src="/assets/conv_setup.png" alt="Experiment Setup" style="display:block; margin-left:auto; margin-right:auto" /></p>
<div align="center">
Experiment Setup
</div>
<p><br />
Here is <a href="https://github.com/hasanunlu/neural_network_deployment_for_uC">the code</a> and <a href="https://arxiv.org/pdf/2007.01348.pdf">arxiv paper</a> that I wrote about memory optimizations.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Experiment Setup Here is the code and arxiv paper that I wrote about memory optimizations.]]></summary></entry><entry><title type="html">Self-Balancing Robot Controlled with Q Learning</title><link href="http://localhost:4000/2019/06/12/Self-Balancing-Robot-Controlled-with-Q-Learning.html" rel="alternate" type="text/html" title="Self-Balancing Robot Controlled with Q Learning" /><published>2019-06-12T21:46:39-07:00</published><updated>2019-06-12T21:46:39-07:00</updated><id>http://localhost:4000/2019/06/12/Self-Balancing-Robot-Controlled-with-Q-Learning</id><content type="html" xml:base="http://localhost:4000/2019/06/12/Self-Balancing-Robot-Controlled-with-Q-Learning.html"><![CDATA[<p>I implemented Q-learning as a substitute for the PID controller in a self-balancing two-wheeled robot. Each vertical position serves as a training iteration. After several steps, the robot learns to maintain its balance autonomously. I’ll be sharing the code soon.</p>

<div class="video-holder">
  <iframe width="315" height="560" src="https://www.youtube.com/embed/bV1DGn6hkEA" frameborder="0" allowfullscreen=""></iframe>
</div>]]></content><author><name></name></author><summary type="html"><![CDATA[I implemented Q-learning as a substitute for the PID controller in a self-balancing two-wheeled robot. Each vertical position serves as a training iteration. After several steps, the robot learns to maintain its balance autonomously. I’ll be sharing the code soon.]]></summary></entry><entry><title type="html">Basic CPU Design in Xilinx Spartan 3E FPGA</title><link href="http://localhost:4000/2018/08/28/Basic-CPU-in-Xilinx-Spartan-3E-FPGA.html" rel="alternate" type="text/html" title="Basic CPU Design in Xilinx Spartan 3E FPGA" /><published>2018-08-28T21:46:39-07:00</published><updated>2018-08-28T21:46:39-07:00</updated><id>http://localhost:4000/2018/08/28/Basic-CPU-in-Xilinx-Spartan-3E-FPGA</id><content type="html" xml:base="http://localhost:4000/2018/08/28/Basic-CPU-in-Xilinx-Spartan-3E-FPGA.html"><![CDATA[<p>This basic CPU runs on Spartan 3E FPGA with basic instructions. It is Von Neumann architecture. Each instruction is 32 bit. ALU(Arithmetic Logic Unit) is capable of 32-bit if operands are loaded from memory. Otherwise direct operations only support 14-bit. <a href="https://github.com/hasanunlu/simple_cpu">My github repo</a> has all necessary files (Design files, binary download, memory dump and example bubble sort assembly file). Unfortunately no interrupt vector support yet. But I will add that soon.</p>

<p><strong>Instruction Word Bit Field Breakdown</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| opcode  |   i   |     A     |     B     |
|  3-bit  | 1-bit |   14-bit  |   14-bit  |
</code></pre></div></div>
<p><br />
<strong>ADD</strong> -&gt; unsigned add</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {0, 0}
*A &lt;- (*A) + (*B)
</code></pre></div></div>
<p><br />
<strong>ADDi</strong> -&gt; unsigned add immediate</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {0, 1}
*A &lt;- (*A) + B
</code></pre></div></div>
<p><br />
<strong>MUL</strong> -&gt; unsigned multiply</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {7, 0}
*A &lt;- (*A) * (*B)
</code></pre></div></div>
<p><br />
<strong>MULi</strong> -&gt; unsigned multiply</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {7, 1}
*A &lt;- (*A) * B
</code></pre></div></div>
<p><br />
<strong>NAND</strong> -&gt; bitwise NAND</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {1, 0}
*A &lt;- ~((*A) &amp; (*B))
</code></pre></div></div>
<p><br />
<strong>NANDi</strong> -&gt; bitwise NAND immediate</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {1, 1}
*A &lt;- ~((*A) &amp; B)
</code></pre></div></div>
<p><br />
<strong>SRL</strong> -&gt; shift right if the shift amount <code class="language-plaintext highlighter-rouge">*B</code> is less than 32, otherwise shift left</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {2, 0}
*A &lt;- (*B) &lt; 32 ? (*A) &gt;&gt; (*B) : (*A) &lt;&lt; ((*B) – 32)
</code></pre></div></div>
<p><br />
<strong>SRLi</strong> -&gt; Shift Right if the shift amount <code class="language-plaintext highlighter-rouge">B</code> is less than 32, otherwise Shift Left</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {2, 1}
*A &lt;- B &lt; 32 ? (*A) &gt;&gt; B : (*A) &lt;&lt; (B – 32)
</code></pre></div></div>
<p><br />
<strong>LT</strong> -&gt; if <code class="language-plaintext highlighter-rouge">*A</code> is less than <code class="language-plaintext highlighter-rouge">*B</code> then <code class="language-plaintext highlighter-rouge">*A</code> is set to 1, otherwise to 0.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {3, 0}
*A &lt;- (*A) &lt; (*B)
</code></pre></div></div>
<p><br />
<strong>LTi</strong> -&gt; if <code class="language-plaintext highlighter-rouge">*A</code> is less than <code class="language-plaintext highlighter-rouge">B</code> then <code class="language-plaintext highlighter-rouge">*A</code> is set to 1, otherwise to 0.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {3, 1}
*A &lt;- (*A) &lt; B
</code></pre></div></div>
<p><br />
<strong>CP</strong> -&gt; copy <code class="language-plaintext highlighter-rouge">*B</code> to <code class="language-plaintext highlighter-rouge">*A</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {4, 0}
*A &lt;- *B
</code></pre></div></div>
<p><br />
<strong>CPi</strong> -&gt; copy <code class="language-plaintext highlighter-rouge">B</code> to <code class="language-plaintext highlighter-rouge">*A</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {4, 1}
*A &lt;- B
</code></pre></div></div>
<p><br />
<strong>CPI</strong> -&gt; copy <code class="language-plaintext highlighter-rouge">**B</code> to <code class="language-plaintext highlighter-rouge">*A</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {5, 0}
*A &lt;- **B
</code></pre></div></div>
<p><br />
<strong>CPIi</strong> -&gt; copy *B to **A</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {5, 1}
**A &lt;- *B
</code></pre></div></div>
<p><br />
<strong>BZJ</strong> -&gt; branch on zero</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {6, 0}
PC &lt;- (*B) == 0 ? (*A) : (PC+1)
</code></pre></div></div>
<p><br />
<strong>BZJi</strong> -&gt; jump</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{opcode, i} = {6, 1}
PC &lt;- (*A) + B
</code></pre></div></div>
<p><br />
Bubble sort algorithm written in this assembly code: <a href="https://raw.githubusercontent.com/hasanunlu/simple_cpu/master/bubble_sort.simplecpuasm.txt">bubble_sort.asm</a></p>

<p><strong>References</strong></p>
<ul>
  <li>The instruction is outlined by H. Fatih Ugurdag in one his graduate FPGA design courses.</li>
</ul>]]></content><author><name></name></author><summary type="html"><![CDATA[This basic CPU runs on Spartan 3E FPGA with basic instructions. It is Von Neumann architecture. Each instruction is 32 bit. ALU(Arithmetic Logic Unit) is capable of 32-bit if operands are loaded from memory. Otherwise direct operations only support 14-bit. My github repo has all necessary files (Design files, binary download, memory dump and example bubble sort assembly file). Unfortunately no interrupt vector support yet. But I will add that soon.]]></summary></entry><entry><title type="html">Full Speed Bit-Bang I2C for RISC-V Architecture HiFive-1 uC Board</title><link href="http://localhost:4000/2018/08/27/Full-Speed-Bit-Bang-I2C-for-RISC-V-Architecture-HiFive-1-uC-Board.html" rel="alternate" type="text/html" title="Full Speed Bit-Bang I2C for RISC-V Architecture HiFive-1 uC Board" /><published>2018-08-27T21:46:39-07:00</published><updated>2018-08-27T21:46:39-07:00</updated><id>http://localhost:4000/2018/08/27/Full-Speed-Bit-Bang-I2C-for-RISC-V-Architecture-HiFive-1-uC-Board</id><content type="html" xml:base="http://localhost:4000/2018/08/27/Full-Speed-Bit-Bang-I2C-for-RISC-V-Architecture-HiFive-1-uC-Board.html"><![CDATA[<p>The HiFive-1 represents the initial Risc-V board compatible with Arduino. Regrettably, it is only equipped with PWM, UART, and SPI hardware. During the past weekend, I developed a bit-bang I2C implementation that clocks up to 400KHz for my HiFive-1 board. The demonstration involves reading data from an MPU6050 sensor for all axes and displaying the Z-axis value in <em>g</em>.</p>

<p><img src="/assets/i2c_prints.png" alt="Reading MPU6050" style="display:block; margin-left:auto; margin-right:auto" /></p>
<div align="center">
Reading MPU6050
</div>
<p><br />
<br />
<img src="/assets/hifive1setup.png" alt="Experiment setup" /></p>
<div align="center">
Experiment setup
</div>

<p>Full source code is <a href="https://github.com/hasanunlu/i2c_demo_for_HiFive1">here</a>.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[The HiFive-1 represents the initial Risc-V board compatible with Arduino. Regrettably, it is only equipped with PWM, UART, and SPI hardware. During the past weekend, I developed a bit-bang I2C implementation that clocks up to 400KHz for my HiFive-1 board. The demonstration involves reading data from an MPU6050 sensor for all axes and displaying the Z-axis value in g.]]></summary></entry><entry><title type="html">Basic 3D Engine in Arduino</title><link href="http://localhost:4000/2018/05/07/Basic-3D-Engine-in-Arduino.html" rel="alternate" type="text/html" title="Basic 3D Engine in Arduino" /><published>2018-05-07T21:46:39-07:00</published><updated>2018-05-07T21:46:39-07:00</updated><id>http://localhost:4000/2018/05/07/Basic-3D-Engine-in-Arduino</id><content type="html" xml:base="http://localhost:4000/2018/05/07/Basic-3D-Engine-in-Arduino.html"><![CDATA[<p>In this experiment, fundamental 3D computer graphics operations, such as rotation, is displayed in LCD using 2D projection of the original object. The frame rate is 45 frames per second, although the display refresh rate is significantly slower than the actual data throughput.</p>

<p>Check out the video.</p>
<div class="video-holder">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/3_ugKHDYY54" frameborder="0" allowfullscreen=""></iframe>
</div>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*********************************************************************
This is simple 3D object rotation and 2D projection example.
It uses 64x48 oled display with SSD1306 controller.
Driving to oled display, Adafruit_SSD1306(this is not original library
64x48 support added by https://github.com/mcauser/Adafruit_SSD1306)
and Adafruit_GFX libraries are used.
*********************************************************************/</span>
<span class="cp">#include</span> <span class="cpf">&lt;Adafruit_GFX.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Adafruit_SSD1306.h&gt;</span><span class="cp">
</span>
<span class="cp">#define OLED_RESET 4  // PIN4
</span><span class="n">Adafruit_SSD1306</span> <span class="nf">display</span><span class="p">(</span><span class="n">OLED_RESET</span><span class="p">);</span>

<span class="kt">float</span> <span class="n">cube</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
<span class="kt">uint8_t</span> <span class="n">point_conn</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">float</span> <span class="n">rad_X</span> <span class="o">=</span> <span class="n">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">rad_Y</span> <span class="o">=</span> <span class="n">PI</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">rad_Z</span> <span class="o">=</span> <span class="n">PI</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">t1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">fps</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">(){</span>  
  <span class="n">display</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">SSD1306_SWITCHCAPVCC</span><span class="p">,</span> <span class="mh">0x3C</span><span class="p">);</span>  
  <span class="n">display</span><span class="p">.</span><span class="n">setTextSize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">display</span><span class="p">.</span><span class="n">setTextColor</span><span class="p">(</span><span class="n">WHITE</span><span class="p">);</span>
  <span class="n">display</span><span class="p">.</span><span class="n">clearDisplay</span><span class="p">();</span>

  <span class="n">createConn</span><span class="p">(</span><span class="n">point_conn</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="cm">/* Define cube corner coordinates */</span>
  <span class="cm">/* Every loop cube needs to start from first shape, otherwise floating point */</span>
  <span class="cm">/* numbers will saturate or go zero */</span>
  <span class="n">createCube</span><span class="p">(</span><span class="n">cube</span><span class="p">);</span>
 
  <span class="n">t1</span> <span class="o">=</span> <span class="n">micros</span><span class="p">();</span>
    
  <span class="n">display</span><span class="p">.</span><span class="n">clearDisplay</span><span class="p">();</span>

  <span class="cm">/* 3D rotation in world coords */</span>
  <span class="n">rotate_X</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">rad_X</span><span class="p">);</span>
  <span class="n">rotate_Y</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">rad_X</span><span class="p">);</span>
  <span class="n">rotate_Z</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">rad_Z</span><span class="p">);</span>
  
  <span class="n">filldispbuffer</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">point_conn</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

  <span class="cm">/* Print FPS */</span>
  <span class="n">display</span><span class="p">.</span><span class="n">setCursor</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
  <span class="n">display</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">fps</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  
  <span class="n">display</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>

  <span class="cm">/* random rotation */</span>
  <span class="n">rad_X</span> <span class="o">+=</span> <span class="mi">0</span><span class="p">.</span><span class="mo">06</span><span class="p">;</span>
  <span class="n">rad_Y</span> <span class="o">+=</span> <span class="mi">0</span><span class="p">.</span><span class="mo">06</span><span class="p">;</span>
  <span class="n">rad_Z</span> <span class="o">+=</span> <span class="mi">0</span><span class="p">.</span><span class="mo">04</span><span class="p">;</span>

  <span class="n">fps</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">micros</span><span class="p">()</span> <span class="o">-</span> <span class="n">t1</span><span class="p">);</span>
  <span class="n">fps</span> <span class="o">=</span> <span class="mi">1000000</span> <span class="o">/</span> <span class="n">fps</span><span class="p">;</span>
  
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">filldispbuffer</span><span class="p">(</span><span class="kt">float</span> <span class="n">obj</span><span class="p">[][</span><span class="mi">3</span><span class="p">],</span> <span class="kt">uint8_t</span> <span class="n">edges</span><span class="p">[][</span><span class="mi">8</span><span class="p">],</span> <span class="kt">uint8_t</span> <span class="n">num_point</span><span class="p">){</span>

  <span class="kt">uint16_t</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">;</span>
     
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]){</span>

        <span class="c1">// Simple 2D projection</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">obj</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span><span class="p">)</span> <span class="o">+</span> <span class="mi">24</span><span class="p">;</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">obj</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span><span class="p">)</span> <span class="o">+</span> <span class="mi">24</span><span class="p">;</span>

        <span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">obj</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span><span class="p">)</span> <span class="o">+</span> <span class="mi">24</span><span class="p">;</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">obj</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span><span class="p">)</span> <span class="o">+</span> <span class="mi">24</span><span class="p">;</span>

        <span class="n">display</span><span class="p">.</span><span class="n">drawLine</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">WHITE</span><span class="p">);</span>
      <span class="p">}</span>  
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rotate_X</span><span class="p">(</span><span class="kt">float</span> <span class="n">result</span><span class="p">[][</span><span class="mi">3</span><span class="p">],</span> <span class="kt">uint8_t</span> <span class="n">num_point</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rad</span><span class="p">){</span>
  <span class="kt">float</span> <span class="n">temp</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_point</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">-</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">);</span>
    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">);</span>
    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>    
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rotate_Y</span><span class="p">(</span><span class="kt">float</span> <span class="n">result</span><span class="p">[][</span><span class="mi">3</span><span class="p">],</span> <span class="kt">uint8_t</span> <span class="n">num_point</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rad</span><span class="p">){</span>
  <span class="kt">float</span> <span class="n">temp</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_point</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">);</span>
    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=-</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">);</span>
    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>    
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rotate_Z</span><span class="p">(</span><span class="kt">float</span> <span class="n">result</span><span class="p">[][</span><span class="mi">3</span><span class="p">],</span> <span class="kt">uint8_t</span> <span class="n">num_point</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rad</span><span class="p">){</span>
  <span class="kt">float</span> <span class="n">temp</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_point</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">-</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">);</span>
    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=-</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">);</span>
    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>    
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* manual definition for cube corner coordinates */</span>
<span class="kt">void</span> <span class="nf">createCube</span><span class="p">(</span><span class="kt">float</span> <span class="n">obj</span><span class="p">[][</span><span class="mi">3</span><span class="p">]){</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

    <span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

    <span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

    <span class="n">obj</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

    <span class="n">obj</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

    <span class="n">obj</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

    <span class="n">obj</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

    <span class="n">obj</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>   
<span class="p">};</span>

<span class="cm">/* manual definition for edge connectivity */</span>
<span class="kt">void</span> <span class="nf">createConn</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">edges</span><span class="p">[][</span><span class="mi">8</span><span class="p">]){</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  
   <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  
   <span class="n">edges</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  
   <span class="n">edges</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  
   <span class="n">edges</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  
   <span class="n">edges</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

   <span class="n">edges</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

   <span class="n">edges</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">edges</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[In this experiment, fundamental 3D computer graphics operations, such as rotation, is displayed in LCD using 2D projection of the original object. The frame rate is 45 frames per second, although the display refresh rate is significantly slower than the actual data throughput.]]></summary></entry><entry><title type="html">Speed of Light Measurement using TI TDC7201</title><link href="http://localhost:4000/2017/10/25/Speed-of-Light-Measurement-using-TI-TDC7201.html" rel="alternate" type="text/html" title="Speed of Light Measurement using TI TDC7201" /><published>2017-10-25T21:46:39-07:00</published><updated>2017-10-25T21:46:39-07:00</updated><id>http://localhost:4000/2017/10/25/Speed-of-Light-Measurement-using-TI-TDC7201</id><content type="html" xml:base="http://localhost:4000/2017/10/25/Speed-of-Light-Measurement-using-TI-TDC7201.html"><![CDATA[<p>In this experiment, the time delay of light in a 15-meter fiber cable is measured using the TDC7201 Time-to-Digital Converter. Commonly available components were utilized for this setup. The fiber cables employed are inexpensive Toslink optical cables. The measured delay in the 15-meter cable is 99.2 ns. In a vacuum, the light would travel the same distance in 50 ns. Generally, the refractive index of fiber cables is 1.3, but this specific cable seem different. In a previous test using a 10-meter cable of the same brand, the measured delay was 65.8 ns, indicating correlation between the results from the same cable type. Their refractive indexes are same.</p>

<p><strong>Component list</strong></p>
<ul>
  <li>Arduino Due or a similar microcontroller with SPI and 3.3V logic level</li>
  <li>TI TDC7201 evaluation board <a href="http://www.ti.com/lit/ds/snas686/snas686.pdf">datasheet</a></li>
  <li>Red light laser</li>
  <li>2 photodiodes</li>
  <li>7404 for basic laser diode driving (or any transistor-based driver would suffice)</li>
  <li>OLED or another display (optional), as output is also provided through the serial terminal</li>
  <li>15-meter optical cable</li>
  <li>Optical splitter</li>
</ul>

<p><img src="/assets/tdc7201_setup.png" alt="Experiment Setup" /></p>
<div align="center">
Experiment setup
</div>
<p><br />
Arduino Due code</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;Adafruit_GFX.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Adafruit_SSD1306.h&gt;</span><span class="cp">
</span>
<span class="c1">//#define OLED_LCD</span>

<span class="cp">#ifdef OLED_LCD
#define OLED_RESET 4
#define NUMFLAKES 10
#define XPOS 0
#define YPOS 1
#define DELTAY 2
#define LOGO16_GLCD_HEIGHT 16 
#define LOGO16_GLCD_WIDTH  16 
</span><span class="n">Adafruit_SSD1306</span> <span class="nf">display</span><span class="p">(</span><span class="n">OLED_RESET</span><span class="p">);</span>
<span class="cp">#endif
</span>
<span class="cp">#define CS        10
#define EN        7
#define TRIGG     4
#define LASER     5
#define FINISH    8
#define FILT_SIZE 64
#define TDC_CLK   8 //8 MHZ
</span>
<span class="k">enum</span> <span class="n">reg_list</span>
<span class="p">{</span>
  <span class="n">TDCx_CONFIG1</span><span class="p">,</span>
  <span class="n">TDCx_CONFIG2</span><span class="p">,</span>
  <span class="n">TDCx_INT_STATUS</span><span class="p">,</span>
  <span class="n">TDCx_INT_MASK</span><span class="p">,</span>
  <span class="n">TDCx_COARSE_CNTR_OVF_H</span><span class="p">,</span>
  <span class="n">TDCx_COARSE_CNTR_OVF_L</span><span class="p">,</span>
  <span class="n">TDCx_CLOCK_CNTR_OVF_H</span><span class="p">,</span>
  <span class="n">TDCx_CLOCK_CNTR_OVF_L</span><span class="p">,</span>
  <span class="n">TDCx_CLOCK_CNTR_STOP_MASK_H</span><span class="p">,</span>
  <span class="n">TDCx_CLOCK_CNTR_STOP_MASK_L</span><span class="p">,</span>
  <span class="n">TDCx_TIME1</span><span class="o">=</span><span class="mh">0x10</span><span class="p">,</span>
  <span class="n">TDCx_CLOCK_COUNT1</span><span class="p">,</span>
  <span class="n">TDCx_TIME2</span><span class="p">,</span>
  <span class="n">TDCx_CLOCK_COUNT2</span><span class="p">,</span>
  <span class="n">TDCx_TIME3</span><span class="p">,</span>
  <span class="n">TDCx_CLOCK_COUNT3</span><span class="p">,</span>
  <span class="n">TDCx_TIME4</span><span class="p">,</span>
  <span class="n">TDCx_CLOCK_COUNT4</span><span class="p">,</span>
  <span class="n">TDCx_TIME5</span><span class="p">,</span>
  <span class="n">TDCx_CLOCK_COUNT5</span><span class="p">,</span>
  <span class="n">TDCx_TIME6</span><span class="p">,</span>
  <span class="n">TDCx_CALIBRATION1</span><span class="p">,</span>
  <span class="n">TDCx_CALIBRATION2</span>
<span class="p">};</span>
<span class="k">enum</span> <span class="n">states</span>
<span class="p">{</span>
  <span class="n">START</span><span class="p">,</span>
  <span class="n">MEASURE</span>
<span class="p">};</span>

<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">trig_ready</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">done</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">last</span><span class="p">[</span><span class="n">FILT_SIZE</span><span class="p">];</span>
<span class="kt">uint8_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">mean</span><span class="p">;</span>

<span class="kt">uint8_t</span> <span class="nf">readRegister</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">reg_add</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">SPI</span><span class="p">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="n">reg_add</span><span class="p">,</span> <span class="n">SPI_CONTINUE</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">SPI</span><span class="p">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">SPI_LAST</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">writeRegister</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">reg_add</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">data</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">SPI</span><span class="p">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">reg_add</span><span class="p">,</span> <span class="n">SPI_CONTINUE</span><span class="p">);</span>
  <span class="n">SPI</span><span class="p">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">SPI_LAST</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">read3</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">reg_add</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">SPI</span><span class="p">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="n">reg_add</span><span class="p">,</span> <span class="n">SPI_CONTINUE</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">SPI</span><span class="p">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">SPI_CONTINUE</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
  <span class="n">data</span> <span class="o">+=</span> <span class="n">SPI</span><span class="p">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">SPI_CONTINUE</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
  <span class="n">data</span> <span class="o">+=</span> <span class="n">SPI</span><span class="p">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">SPI_LAST</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">trigger</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">trig_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">finish</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>

<span class="cp">#ifdef OLED_LCD
</span>  <span class="c1">// initialize with the I2C addr 0x3C (for the 128x32)</span>
  <span class="n">display</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">SSD1306_SWITCHCAPVCC</span><span class="p">,</span> <span class="mh">0x3C</span><span class="p">);</span>  
  <span class="n">display</span><span class="p">.</span><span class="n">clearDisplay</span><span class="p">();</span>
  
  <span class="n">display</span><span class="p">.</span><span class="n">setTextSize</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">display</span><span class="p">.</span><span class="n">setTextColor</span><span class="p">(</span><span class="n">WHITE</span><span class="p">);</span>
  <span class="n">display</span><span class="p">.</span><span class="n">setCursor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">display</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"TDC"</span><span class="p">);</span> 
  <span class="n">display</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
<span class="cp">#endif
</span>
  <span class="c1">// initialize digital pin LED_BUILTIN as an output.</span>
  <span class="n">SPI</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">CS</span><span class="p">);</span>
  <span class="n">SPI</span><span class="p">.</span><span class="n">beginTransaction</span><span class="p">(</span><span class="n">SPISettings</span><span class="p">(</span><span class="mi">50000</span><span class="p">,</span> <span class="n">MSBFIRST</span><span class="p">,</span> <span class="n">SPI_MODE0</span><span class="p">));</span>
  <span class="n">SPI</span><span class="p">.</span><span class="n">setClockDivider</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="mi">84</span><span class="p">);</span>

  <span class="n">pinMode</span><span class="p">(</span><span class="n">LED_BUILTIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">LASER</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">EN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LASER</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span> 

  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span> 
  <span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> 
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span> 
  <span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>  

<span class="cp">#ifdef OLED_LCD
</span>  <span class="n">display</span><span class="p">.</span><span class="n">clearDisplay</span><span class="p">();</span>
  <span class="n">display</span><span class="p">.</span><span class="n">setCursor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">display</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"0x"</span><span class="p">);</span> 
  <span class="n">display</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">readRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">HEX</span><span class="p">);</span>
  <span class="n">display</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"0x"</span><span class="p">);</span> 
  <span class="n">display</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">readRegister</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">HEX</span><span class="p">);</span>
  <span class="n">display</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
<span class="cp">#endif
</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

  <span class="n">pinMode</span><span class="p">(</span><span class="n">TRIGG</span><span class="p">,</span> <span class="n">INPUT_PULLUP</span><span class="p">);</span>
  <span class="n">attachInterrupt</span><span class="p">(</span><span class="n">TRIGG</span><span class="p">,</span> <span class="n">trigger</span><span class="p">,</span> <span class="n">RISING</span><span class="p">);</span>
  
  <span class="n">pinMode</span><span class="p">(</span><span class="n">FINISH</span><span class="p">,</span> <span class="n">INPUT_PULLUP</span><span class="p">);</span>
  <span class="n">attachInterrupt</span><span class="p">(</span><span class="n">FINISH</span><span class="p">,</span> <span class="n">finish</span><span class="p">,</span> <span class="n">FALLING</span><span class="p">);</span>
  <span class="n">interrupts</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">tof</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">read3</span><span class="p">(</span><span class="n">TDCx_CALIBRATION2</span><span class="p">);</span>
  <span class="n">diff</span> <span class="o">-=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">read3</span><span class="p">(</span><span class="n">TDCx_CALIBRATION1</span><span class="p">);</span>
  <span class="n">diff</span> <span class="o">/=</span> <span class="p">(</span><span class="mi">10</span><span class="p">.</span><span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1000</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="n">TDC_CLK</span><span class="p">)</span> <span class="o">/</span> <span class="n">diff</span><span class="p">;</span>
  <span class="n">diff</span> <span class="o">*=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">read3</span><span class="p">(</span><span class="n">TDCx_TIME1</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">diff</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">state</span><span class="p">){</span>
  <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">writeRegister</span><span class="p">(</span><span class="n">TDCx_CONFIG1</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">);</span>
    <span class="n">state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">if</span><span class="p">(</span><span class="n">trig_ready</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">trig_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LASER</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span> 
      <span class="n">state</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">break</span><span class="p">;</span>  
  <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LASER</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span> 
      <span class="n">state</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> 
    <span class="p">}</span>
  <span class="k">break</span><span class="p">;</span>  
  <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
    <span class="n">last</span><span class="p">[</span><span class="o">++</span><span class="n">i</span> <span class="o">%</span> <span class="n">FILT_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="n">tof</span><span class="p">();</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">FILT_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="n">mean</span> <span class="o">+=</span> <span class="n">last</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">mean</span> <span class="o">/</span> <span class="n">FILT_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="cp">#ifdef OLED_LCD
</span>    <span class="n">noInterrupts</span><span class="p">();</span>
    
    <span class="n">display</span><span class="p">.</span><span class="n">clearDisplay</span><span class="p">();</span>
    <span class="n">display</span><span class="p">.</span><span class="n">setTextSize</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">display</span><span class="p">.</span><span class="n">setTextColor</span><span class="p">(</span><span class="n">WHITE</span><span class="p">);</span>
    <span class="n">display</span><span class="p">.</span><span class="n">setCursor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">display</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">mean</span> <span class="o">/</span> <span class="n">FILT_SIZE</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> 
    <span class="n">display</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">" ns"</span><span class="p">);</span>
    <span class="n">display</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
    <span class="n">interrupts</span><span class="p">();</span>
<span class="cp">#endif
</span>    <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">break</span><span class="p">;</span>
  <span class="nl">default:</span>
  <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[In this experiment, the time delay of light in a 15-meter fiber cable is measured using the TDC7201 Time-to-Digital Converter. Commonly available components were utilized for this setup. The fiber cables employed are inexpensive Toslink optical cables. The measured delay in the 15-meter cable is 99.2 ns. In a vacuum, the light would travel the same distance in 50 ns. Generally, the refractive index of fiber cables is 1.3, but this specific cable seem different. In a previous test using a 10-meter cable of the same brand, the measured delay was 65.8 ns, indicating correlation between the results from the same cable type. Their refractive indexes are same.]]></summary></entry><entry><title type="html">Intermediate Axis Theorem</title><link href="http://localhost:4000/2017/10/24/Intermediate-Axis-Theorem.html" rel="alternate" type="text/html" title="Intermediate Axis Theorem" /><published>2017-10-24T21:46:39-07:00</published><updated>2017-10-24T21:46:39-07:00</updated><id>http://localhost:4000/2017/10/24/Intermediate-Axis-Theorem</id><content type="html" xml:base="http://localhost:4000/2017/10/24/Intermediate-Axis-Theorem.html"><![CDATA[<p>The intermediate axis theorem is an unintuitive concept in physics that occurs when a rigid object has incrementally larger moments of inertia for each of its orthogonal axes. When the object is spun around the axis with the intermediate moment of inertia, The direction of that axis oscillates.</p>

<p>Check out this video for a demonstration: Dancing T-handle in zero-g</p>
<div class="video-holder">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/1n-HMSCDYtM" frameborder="0" allowfullscreen=""></iframe>
</div>

<p>We can write the following differential equations for the system.</p>

\[I_{1}\dot\omega_{1} + (I_{3}-I_{2})\omega_{2}\omega_{3} = \tau_{1}\]

\[I_{2}\dot\omega_{2} + (I_{1}-I_{3})\omega_{1}\omega_{3} = \tau_{2}\]

\[I_{3}\dot\omega_{3} + (I_{2}-I_{1})\omega_{1}\omega_{2} = \tau_{3}\]

<p>In this scenario, $\tau_{1}$, $\tau_{2}$ and $\tau_{3}$ are all zero since no external torque is being applied. Assume $I_1 &lt; I_2 &lt; I_3$, $w_1 \approx 0$, $w_3 \approx 0$ and $w_2 \neq 0$. In order to compute solutions for this ordinary differential equation system numerically, the following python code snippet can be used.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">odeint</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I1</span><span class="p">,</span> <span class="n">I2</span><span class="p">,</span> <span class="n">I3</span><span class="p">):</span>
    <span class="n">omega_1</span><span class="p">,</span> <span class="n">omega_2</span><span class="p">,</span> <span class="n">omega_3</span> <span class="o">=</span> <span class="n">y</span>
    <span class="n">dydt</span> <span class="o">=</span> <span class="p">[(</span><span class="n">I2</span> <span class="o">-</span> <span class="n">I3</span><span class="p">)</span> <span class="o">*</span> <span class="n">omega_2</span> <span class="o">*</span> <span class="n">omega_3</span> <span class="o">/</span> <span class="n">I1</span><span class="p">,</span>
            <span class="p">(</span><span class="n">I3</span> <span class="o">-</span> <span class="n">I1</span><span class="p">)</span> <span class="o">*</span> <span class="n">omega_1</span> <span class="o">*</span> <span class="n">omega_3</span> <span class="o">/</span> <span class="n">I2</span><span class="p">,</span>
            <span class="p">(</span><span class="n">I1</span> <span class="o">-</span> <span class="n">I2</span><span class="p">)</span> <span class="o">*</span> <span class="n">omega_1</span> <span class="o">*</span> <span class="n">omega_2</span> <span class="o">/</span> <span class="n">I3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dydt</span>

<span class="c1"># Inertia
</span><span class="n">I1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">I2</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">I3</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]</span> <span class="c1"># Initial conditions
</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">I1</span><span class="p">,</span> <span class="n">I2</span><span class="p">,</span> <span class="n">I3</span><span class="p">))</span>

<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s">'b'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'w_1(t)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s">'r'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'w_2(t)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="s">'g'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'w_3(t)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p>The numerical resolution of the differential equation system indicates that $w_2$ oscillates between $-4$ and $4$. During the transition in axis direction, $w_1$ and $w_3$ briefly become non-zero for a very short duration during the transitions.
<img src="/assets/intermediate_axis.png" alt="Angular velocities" /></p>]]></content><author><name></name></author><summary type="html"><![CDATA[The intermediate axis theorem is an unintuitive concept in physics that occurs when a rigid object has incrementally larger moments of inertia for each of its orthogonal axes. When the object is spun around the axis with the intermediate moment of inertia, The direction of that axis oscillates.]]></summary></entry></feed>